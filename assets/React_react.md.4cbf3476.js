import{_ as l,C as s,o as n,c as r,H as o,Q as a}from"./chunks/framework.7e1733e5.js";const f=JSON.parse('{"title":"第1章：React入门","description":"","frontmatter":{},"headers":[],"relativePath":"React/react.md","filePath":"React/react.md","lastUpdated":1699034132000}'),t={name:"React/react.md"},i=a('<h1 id="第1章-react入门" tabindex="-1">第1章：React入门 <a class="header-anchor" href="#第1章-react入门" aria-label="Permalink to &quot;第1章：React入门&quot;">​</a></h1><h2 id="_1-1-react简介" tabindex="-1">1.1 React简介 <a class="header-anchor" href="#_1-1-react简介" aria-label="Permalink to &quot;1.1 React简介&quot;">​</a></h2><h3 id="_1-1-1-官网" tabindex="-1">1.1.1 官网 <a class="header-anchor" href="#_1-1-1-官网" aria-label="Permalink to &quot;1.1.1 官网&quot;">​</a></h3><ol><li>英文官网:<a href="https://reactjs.org/" target="_blank" rel="noreferrer">https://reactjs.org/</a></li><li>中文官网: <a href="https://react.docschina.org/" target="_blank" rel="noreferrer">https://react.docschina.org/</a></li><li></li></ol><h3 id="_1-1-2-介绍描述" tabindex="-1">1.1.2 介绍描述 <a class="header-anchor" href="#_1-1-2-介绍描述" aria-label="Permalink to &quot;1.1.2 介绍描述&quot;">​</a></h3><ol><li>用于动态构建用户界面的 JavaScript 库(只关注于视图)</li><li>由Facebook开源</li></ol><h3 id="_1-1-3-react的特点" tabindex="-1">1.1.3 React的特点 <a class="header-anchor" href="#_1-1-3-react的特点" aria-label="Permalink to &quot;1.1.3 React的特点&quot;">​</a></h3><ol><li>声明式编码</li><li>组件化编码</li><li>React Native 编写原生应用</li><li>高效（优秀的Diffing算法）</li></ol><h3 id="_1-1-4-react高效的原因" tabindex="-1">1.1.4 React高效的原因 <a class="header-anchor" href="#_1-1-4-react高效的原因" aria-label="Permalink to &quot;1.1.4 React高效的原因&quot;">​</a></h3><ol><li>使用虚拟(virtual)DOM, 不总是直接操作页面真实DOM。</li><li>DOM Diffing算法, 最小化页面重绘。</li></ol><h2 id="_1-2-react的基本使用" tabindex="-1">1.2 React的基本使用 <a class="header-anchor" href="#_1-2-react的基本使用" aria-label="Permalink to &quot;1.2 React的基本使用&quot;">​</a></h2><h3 id="_1-2-1-效果" tabindex="-1">1.2.1 效果 <a class="header-anchor" href="#_1-2-1-效果" aria-label="Permalink to &quot;1.2.1 效果&quot;">​</a></h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35560689/1690360344032-d156fe9d-8901-492b-86d4-2af4fe011864.png#averageHue=%23f4f1f0&amp;id=hzqQt&amp;originHeight=292&amp;originWidth=310&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="png"></p><h3 id="_0-2-2-相关js库" tabindex="-1">0.2.2 相关js库 <a class="header-anchor" href="#_0-2-2-相关js库" aria-label="Permalink to &quot;0.2.2 相关js库&quot;">​</a></h3><ol><li>react.js：React核心库。</li><li>react-dom.js：提供操作DOM的react扩展库。</li><li>babel.min.js：解析JSX语法代码转为JS代码的库。</li></ol><h3 id="_1-2-3-创建虚拟dom的两种方式" tabindex="-1">1.2.3 创建虚拟DOM的两种方式 <a class="header-anchor" href="#_1-2-3-创建虚拟dom的两种方式" aria-label="Permalink to &quot;1.2.3 创建虚拟DOM的两种方式&quot;">​</a></h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35560689/1690360344310-5290a156-6854-4f56-9642-399f3a1926f4.png#averageHue=%23f4efef&amp;id=THmlP&amp;originHeight=340&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="png"></p><ol><li>纯JS方式(一般不用)</li><li>JSX方式</li></ol><h3 id="_1-2-4-虚拟dom与真实dom" tabindex="-1">1.2.4 虚拟DOM与真实DOM <a class="header-anchor" href="#_1-2-4-虚拟dom与真实dom" aria-label="Permalink to &quot;1.2.4 虚拟DOM与真实DOM&quot;">​</a></h3><ol><li>React提供了一些API来创建一种 “特别” 的一般js对象 <ul><li>const VDOM = React.createElement(&#39;xx&#39;,{id:&#39;xx&#39;},&#39;xx&#39;)</li><li>上面创建的就是一个简单的虚拟DOM对象</li></ul></li><li>虚拟DOM对象最终都会被React转换为真实的DOM</li><li>我们编码时基本只需要操作react的虚拟DOM相关数据, react会转换为真实DOM变化而更新界。</li></ol><h2 id="_1-3-react-jsx" tabindex="-1">1.3 React JSX <a class="header-anchor" href="#_1-3-react-jsx" aria-label="Permalink to &quot;1.3 React JSX&quot;">​</a></h2><h3 id="_1-3-1-效果" tabindex="-1">1.3.1 效果 <a class="header-anchor" href="#_1-3-1-效果" aria-label="Permalink to &quot;1.3.1 效果&quot;">​</a></h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35560689/1690360344562-1d9ddd91-2c93-461f-ae42-bcdb3d177f72.png#averageHue=%23f7f4f3&amp;id=FdOP6&amp;originHeight=447&amp;originWidth=532&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="png"></p><h3 id="_1-3-2-jsx" tabindex="-1">1.3.2 JSX <a class="header-anchor" href="#_1-3-2-jsx" aria-label="Permalink to &quot;1.3.2 JSX&quot;">​</a></h3><ol><li>全称: JavaScript XML</li><li>react定义的一种类似于XML的JS扩展语法: JS + XML本质是React.createElement(component, props, ...children)方法的语法糖</li><li>作用: 用来简化创建虚拟DOM <ol><li>写法：var ele = <h1>Hello JSX!</h1></li><li>注意1：它不是字符串, 也不是HTML/XML标签</li><li>注意2：它最终产生的就是一个JS对象</li></ol></li><li>标签名任意: HTML标签或其它标签</li><li>标签属性任意: HTML标签属性或其它</li><li>基本语法规则 <ol><li>遇到 &lt;开头的代码, 以标签的语法解析: html同名标签转换为html同名元素, 其它标签需要特别解析</li><li>遇到以 { 开头的代码，以JS语法解析: 标签中的js表达式必须用{ }包含</li></ol></li><li>babel.js的作用 <ol><li>浏览器不能直接解析JSX代码, 需要babel转译为纯JS的代码才能运行</li><li>只要用了JSX，都要加上type=&quot;text/babel&quot;, 声明需要babel来处理</li></ol></li></ol><h3 id="_0-3-3-渲染虚拟dom-元素" tabindex="-1">0.3.3 渲染虚拟DOM(元素) <a class="header-anchor" href="#_0-3-3-渲染虚拟dom-元素" aria-label="Permalink to &quot;0.3.3 渲染虚拟DOM(元素)&quot;">​</a></h3><ol><li>语法: ReactDOM.render(virtualDOM, containerDOM)</li><li>作用: 将虚拟DOM元素渲染到页面中的真实容器DOM中显示</li><li>参数说明 <ol><li>参数一: 纯js或jsx创建的虚拟dom对象</li><li>参数二: 用来包含虚拟DOM元素的真实dom元素对象(一般是一个div)</li></ol></li></ol><h3 id="_0-3-4-jsx练习" tabindex="-1">0.3.4 JSX练习 <a class="header-anchor" href="#_0-3-4-jsx练习" aria-label="Permalink to &quot;0.3.4 JSX练习&quot;">​</a></h3><p>需求: 动态展示如下列表 <img src="https://cdn.nlark.com/yuque/0/2023/png/35560689/1690360344759-aa3f8793-0d15-4c65-a1d6-efef94adaa94.png#averageHue=%23efeeed&amp;id=W0qjH&amp;originHeight=209&amp;originWidth=244&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="png"></p><h2 id="_1-4-模块与组件、模块化与组件化的理解" tabindex="-1">1.4 模块与组件、模块化与组件化的理解 <a class="header-anchor" href="#_1-4-模块与组件、模块化与组件化的理解" aria-label="Permalink to &quot;1.4 模块与组件、模块化与组件化的理解&quot;">​</a></h2><h3 id="_1-4-1-模块" tabindex="-1">1.4.1 模块 <a class="header-anchor" href="#_1-4-1-模块" aria-label="Permalink to &quot;1.4.1 模块&quot;">​</a></h3><ol><li>理解：向外提供特定功能的js程序, 一般就是一个js文件</li><li>为什么要拆成模块：随着业务逻辑增加，代码越来越多且复杂。</li><li>作用：复用js, 简化js的编写, 提高js运行效率</li></ol><h3 id="_1-4-2-组件" tabindex="-1">1.4.2 组件 <a class="header-anchor" href="#_1-4-2-组件" aria-label="Permalink to &quot;1.4.2 组件&quot;">​</a></h3><ol><li>理解：用来实现局部功能效果的代码和资源的集合(html/css/js/image等等)</li><li>为什么要用组件： 一个界面的功能更复杂</li><li>作用：复用编码, 简化项目编码, 提高运行效率</li></ol><h3 id="_1-4-3-模块化" tabindex="-1">1.4.3 模块化 <a class="header-anchor" href="#_1-4-3-模块化" aria-label="Permalink to &quot;1.4.3 模块化&quot;">​</a></h3><p>当应用的js都以模块来编写的, 这个应用就是一个模块化的应用</p><h3 id="_1-4-4-组件化" tabindex="-1">1.4.4 组件化 <a class="header-anchor" href="#_1-4-4-组件化" aria-label="Permalink to &quot;1.4.4 组件化&quot;">​</a></h3><p>当应用是以多组件的方式实现, 这个应用就是一个组件化的应用</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35560689/1690360345046-cb7e7b02-3469-4bd3-b64e-d5ddbc8d3946.png#averageHue=%23add7ae&amp;id=UwQ2t&amp;originHeight=1213&amp;originWidth=2097&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="png"></p><h1 id="第2章-react面向组件编程" tabindex="-1">第2章：React面向组件编程 <a class="header-anchor" href="#第2章-react面向组件编程" aria-label="Permalink to &quot;第2章：React面向组件编程&quot;">​</a></h1><h2 id="_2-1-基本理解和使用" tabindex="-1">2.1. 基本理解和使用 <a class="header-anchor" href="#_2-1-基本理解和使用" aria-label="Permalink to &quot;2.1. 基本理解和使用&quot;">​</a></h2><h3 id="_2-1-1-使用react开发者工具调试" tabindex="-1">2.1.1. 使用React开发者工具调试 <a class="header-anchor" href="#_2-1-1-使用react开发者工具调试" aria-label="Permalink to &quot;2.1.1. 使用React开发者工具调试&quot;">​</a></h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35560689/1690360345327-135238a5-0535-4c17-8139-8c9b8303cfca.png#averageHue=%23fdfcfc&amp;id=kUseu&amp;originHeight=293&amp;originWidth=1122&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="png"></p><h3 id="_2-1-2-效果" tabindex="-1">2.1.2. 效果 <a class="header-anchor" href="#_2-1-2-效果" aria-label="Permalink to &quot;2.1.2. 效果&quot;">​</a></h3><p>函数式组件：</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35560689/1690360345582-ff4f409f-bc78-4449-8689-d4c1102dab94.png#averageHue=%23f0eeee&amp;id=pCkvA&amp;originHeight=408&amp;originWidth=934&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="png"></p><p>类式组件：</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35560689/1690360345842-ecc7e2a8-a2c4-4581-b4c8-f1eb00c19446.png#averageHue=%23efeeee&amp;id=Jz01w&amp;originHeight=612&amp;originWidth=1585&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="png"></p><h3 id="_2-1-3-注意" tabindex="-1">2.1.3. 注意 <a class="header-anchor" href="#_2-1-3-注意" aria-label="Permalink to &quot;2.1.3. 注意&quot;">​</a></h3><ol><li>组件名必须首字母大写</li><li>虚拟DOM元素只能有一个根元素</li><li>虚拟DOM元素必须有结束标签</li></ol><h3 id="_2-1-4-渲染类组件标签的基本流程" tabindex="-1">2.1.4. 渲染类组件标签的基本流程 <a class="header-anchor" href="#_2-1-4-渲染类组件标签的基本流程" aria-label="Permalink to &quot;2.1.4. 渲染类组件标签的基本流程&quot;">​</a></h3><ol><li>React内部会创建组件实例对象</li><li>调用render()得到虚拟DOM, 并解析为真实DOM</li><li>插入到指定的页面元素内部</li></ol><h2 id="_2-2-组件三大核心属性1-state" tabindex="-1">2.2. 组件三大核心属性1: state <a class="header-anchor" href="#_2-2-组件三大核心属性1-state" aria-label="Permalink to &quot;2.2. 组件三大核心属性1: state&quot;">​</a></h2><h3 id="_2-2-1-效果" tabindex="-1">2.2.1. 效果 <a class="header-anchor" href="#_2-2-1-效果" aria-label="Permalink to &quot;2.2.1. 效果&quot;">​</a></h3><p>_需求: 定义一个展示天气信息的组件</p><ol><li><em>默认展示天气炎热 或 凉爽</em></li><li><em>点击文字切换天气</em></li></ol><h3 id="_2-2-2-理解" tabindex="-1">2.2.2. 理解 <a class="header-anchor" href="#_2-2-2-理解" aria-label="Permalink to &quot;2.2.2. 理解&quot;">​</a></h3><ol><li>state是组件对象最重要的属性, 值是对象(可以包含多个key-value的组合)</li><li>组件被称为&quot;状态机&quot;, 通过更新组件的state来更新对应的页面显示(重新渲染组件)</li></ol><h3 id="_2-2-3-强烈注意" tabindex="-1">2.2.3. 强烈注意 <a class="header-anchor" href="#_2-2-3-强烈注意" aria-label="Permalink to &quot;2.2.3. 强烈注意&quot;">​</a></h3><ol><li>组件中render方法中的this为组件实例对象</li><li>组件自定义的方法中this为undefined，如何解决？ <ol><li>强制绑定this: 通过函数对象的bind()</li><li>箭头函数</li></ol></li><li>状态数据，不能直接修改或更新</li></ol><h2 id="_2-3-组件三大核心属性2-props" tabindex="-1">2.3. 组件三大核心属性2: props <a class="header-anchor" href="#_2-3-组件三大核心属性2-props" aria-label="Permalink to &quot;2.3. 组件三大核心属性2: props&quot;">​</a></h2><h3 id="_2-3-1-效果" tabindex="-1">2.3.1. 效果 <a class="header-anchor" href="#_2-3-1-效果" aria-label="Permalink to &quot;2.3.1. 效果&quot;">​</a></h3><p>需求: 自定义用来显示一个人员信息的组件_</p><ol><li><em>姓名必须指定，且为字符串类型；</em></li><li><em>性别为字符串类型，如果性别没有指定，默认为男</em></li><li><em>年龄为字符串类型，且为数字类型，默认值为18</em></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35560689/1690360346180-71cd46a5-34d2-4ddb-b90d-ad700dc5799e.png#averageHue=%23f9f8f7&amp;id=YOssD&amp;originHeight=212&amp;originWidth=229&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="png"></p><h3 id="_2-3-2-理解" tabindex="-1">2.3.2. 理解 <a class="header-anchor" href="#_2-3-2-理解" aria-label="Permalink to &quot;2.3.2. 理解&quot;">​</a></h3><ol><li>每个组件对象都会有props(properties的简写)属性</li><li>组件标签的所有属性都保存在props中</li></ol><h3 id="_2-3-3-作用" tabindex="-1">2.3.3. 作用 <a class="header-anchor" href="#_2-3-3-作用" aria-label="Permalink to &quot;2.3.3. 作用&quot;">​</a></h3><ol><li>通过标签属性从组件外向组件内传递变化的数据</li><li>注意: 组件内部不要修改props数据</li></ol><h3 id="_2-3-4-编码操作" tabindex="-1">2.3.4. 编码操作 <a class="header-anchor" href="#_2-3-4-编码操作" aria-label="Permalink to &quot;2.3.4. 编码操作&quot;">​</a></h3><ol><li>内部读取某个属性值</li></ol><p>this.props.name</p><ol><li>对props中的属性值进行类型限制和必要性限制</li></ol><p>第一种方式（React v15.5 开始已弃用）： <em>Person</em>.propTypes= { name: React.PropTypes.string.isRequired, age: React.PropTypes.number } 第二种方式（新）：使用prop-types库进限制（需要引入prop-types库）</p><p><em>Person</em>.propTypes= { name: PropTypes.string.isRequired, age: PropTypes.number. }</p><ol><li>扩展属性: 将对象的所有属性通过props传递</li></ol>',76),p=a(`<ol><li>默认属性值：</li></ol><p>Person.defaultProps = { age: 18, sex:&#39;男&#39;}</p><ol><li>组件类的构造函数</li></ol><p>constructor(props){ super(props) console.log(props)<em>//打印所有属性</em>}</p><h2 id="_2-4-组件三大核心属性3-refs与事件处理" tabindex="-1">2.4. 组件三大核心属性3: refs与事件处理 <a class="header-anchor" href="#_2-4-组件三大核心属性3-refs与事件处理" aria-label="Permalink to &quot;2.4. 组件三大核心属性3: refs与事件处理&quot;">​</a></h2><h3 id="_2-4-1-效果" tabindex="-1">2.4.1. 效果 <a class="header-anchor" href="#_2-4-1-效果" aria-label="Permalink to &quot;2.4.1. 效果&quot;">​</a></h3><p><em>需求: 自定义组件, 功能说明如下:</em><em>1. 点击按钮, 提示第一个输入框中的值</em><em>2. 当第2个输入框失去焦点时, 提示这个输入框中的值</em> 效果如下：</p><h3 id="_2-4-2-理解" tabindex="-1">2.4.2. 理解 <a class="header-anchor" href="#_2-4-2-理解" aria-label="Permalink to &quot;2.4.2. 理解&quot;">​</a></h3><p>组件内的标签可以定义ref属性来标识自己</p><h3 id="_2-4-3-编码" tabindex="-1">2.4.3. 编码 <a class="header-anchor" href="#_2-4-3-编码" aria-label="Permalink to &quot;2.4.3. 编码&quot;">​</a></h3><ol><li>字符串形式的ref</li></ol><div class="language-html line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki one-dark-pro"><code><span class="line"><span style="color:#ABB2BF;">&lt;</span><span style="color:#E06C75;">input</span><span style="color:#D19A66;"> ref</span><span style="color:#ABB2BF;">=</span><span style="color:#98C379;">&quot;input1&quot;</span><span style="color:#ABB2BF;">/&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><ol><li>回调形式的ref</li></ol><div class="language-jsx line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki one-dark-pro"><code><span class="line"><span style="color:#ABB2BF;">&lt;</span><span style="color:#E06C75;">input</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;font-style:italic;">ref</span><span style="color:#56B6C2;">=</span><span style="color:#C678DD;">{</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;font-style:italic;">c</span><span style="color:#ABB2BF;">)</span><span style="color:#C678DD;">=&gt;</span><span style="color:#ABB2BF;">{</span><span style="color:#E5C07B;">this</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">input1</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">c</span><span style="color:#ABB2BF;">}</span><span style="color:#C678DD;">}</span><span style="color:#ABB2BF;">/&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><ol><li>createRef创建ref容器·</li></ol><div class="language-jsx line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki one-dark-pro"><code><span class="line"><span style="color:#C678DD;">const</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">myRef</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">React</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">createRef</span><span style="color:#ABB2BF;">()</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ABB2BF;">&lt;</span><span style="color:#E06C75;">input</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;font-style:italic;">ref</span><span style="color:#56B6C2;">=</span><span style="color:#C678DD;">{</span><span style="color:#E5C07B;">this</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">myRef</span><span style="color:#C678DD;">}</span><span style="color:#ABB2BF;">/&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="_2-4-4-事件处理" tabindex="-1">2.4.4. 事件处理 <a class="header-anchor" href="#_2-4-4-事件处理" aria-label="Permalink to &quot;2.4.4. 事件处理&quot;">​</a></h3><ol><li>通过onXxx属性指定事件处理函数(注意大小写) <ol><li>React使用的是自定义(合成)事件, 而不是使用的原生DOM事件</li><li>React中的事件是通过事件委托方式处理的(委托给组件最外层的元素)</li></ol></li><li>通过event.target得到发生事件的DOM元素对象</li></ol><h2 id="_2-5-收集表单数据" tabindex="-1">2.5. 收集表单数据 <a class="header-anchor" href="#_2-5-收集表单数据" aria-label="Permalink to &quot;2.5. 收集表单数据&quot;">​</a></h2><h3 id="_2-5-1-效果" tabindex="-1">2.5.1. 效果 <a class="header-anchor" href="#_2-5-1-效果" aria-label="Permalink to &quot;2.5.1. 效果&quot;">​</a></h3><p><em>需求: 定义一个包含表单的组件</em><em>输入用户名密码后, 点击登录提示输入信息</em></p><h3 id="_2-5-2-理解" tabindex="-1">2.5.2. 理解 <a class="header-anchor" href="#_2-5-2-理解" aria-label="Permalink to &quot;2.5.2. 理解&quot;">​</a></h3><p>包含表单的组件分类</p><ol><li>受控组件</li><li>非受控组件</li></ol><h2 id="_2-6-组件的生命周期" tabindex="-1">2.6. 组件的生命周期 <a class="header-anchor" href="#_2-6-组件的生命周期" aria-label="Permalink to &quot;2.6. 组件的生命周期&quot;">​</a></h2><h3 id="_2-6-1-效果" tabindex="-1">2.6.1. 效果 <a class="header-anchor" href="#_2-6-1-效果" aria-label="Permalink to &quot;2.6.1. 效果&quot;">​</a></h3><p><em>需求:定义组件实现以下功能：</em><em>1. 让指定的文本做显示 / 隐藏的渐变动画</em><em>2. 从完全可见，到彻底消失，耗时2S</em><em>3. 点击“不活了”按钮从界面中卸载组件</em></p><h3 id="_2-6-2-理解" tabindex="-1">2.6.2. 理解 <a class="header-anchor" href="#_2-6-2-理解" aria-label="Permalink to &quot;2.6.2. 理解&quot;">​</a></h3><ol><li>组件从创建到死亡它会经历一些特定的阶段。</li><li>React组件中包含一系列勾子函数(生命周期回调函数), 会在特定的时刻调用。</li><li>我们在定义组件时，会在特定的生命周期回调函数中，做特定的工作。</li></ol><h3 id="_2-6-3-生命周期流程图-旧" tabindex="-1">2.6.3. 生命周期流程图(旧) <a class="header-anchor" href="#_2-6-3-生命周期流程图-旧" aria-label="Permalink to &quot;2.6.3. 生命周期流程图(旧)&quot;">​</a></h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35560689/1690360346616-6e27fdb4-16b2-4aad-9aa4-b3094e27b833.png#averageHue=%23f5f5f5&amp;id=boMfS&amp;originHeight=670&amp;originWidth=841&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="png"></p><p>生命周期的三个阶段（旧）</p><ol><li>初始化阶段: 由ReactDOM.render()触发---初次渲染</li><li>constructor()</li><li>componentWillMount()</li><li>render()</li><li>componentDidMount()</li></ol><p>更新阶段:由组件内部this.setSate()或父组件重新render触发</p><ol><li>shouldComponentUpdate()</li><li>componentWillUpdate()</li><li>render()</li><li>componentDidUpdate() 卸载组件:由ReactDOM.unmountComponentAtNode()触发</li></ol><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-dark-pro"><code><span class="line"><span style="color:#61AFEF;">componentWillUnmount</span><span style="color:#ABB2BF;">()</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h3 id="_2-6-4-生命周期流程图-新" tabindex="-1">2.6.4. 生命周期流程图(新) <a class="header-anchor" href="#_2-6-4-生命周期流程图-新" aria-label="Permalink to &quot;2.6.4. 生命周期流程图(新)&quot;">​</a></h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35560689/1690360346876-e9667036-69ff-438b-bc03-1c9ac845c97b.png#averageHue=%23f5f4f1&amp;id=RAtvm&amp;originHeight=654&amp;originWidth=941&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="png"></p><p>生命周期的三个阶段（新）</p><ol><li><p>初始化阶段: 由ReactDOM.render()触发---初次渲染</p></li><li><p>constructor()</p></li><li><p>getDerivedStateFromProps</p></li><li><p>render()</p></li><li><p>componentDidMount()</p></li><li><p>更新阶段:由组件内部this.setSate()或父组件重新render触发</p></li><li><p>getDerivedStateFromProps</p></li><li><p>shouldComponentUpdate()</p></li><li><p>render()</p></li><li><p>getSnapshotBeforeUpdate</p></li><li><p>componentDidUpdate()</p></li><li><p>卸载组件:由ReactDOM.unmountComponentAtNode()触发</p></li><li><p>componentWillUnmount()</p></li></ol><h3 id="_2-6-5-重要的勾子" tabindex="-1">2.6.5. 重要的勾子 <a class="header-anchor" href="#_2-6-5-重要的勾子" aria-label="Permalink to &quot;2.6.5. 重要的勾子&quot;">​</a></h3><ol><li>render：初始化渲染或更新渲染调用</li><li>componentDidMount：开启监听, 发送ajax请求</li><li>componentWillUnmount：做一些收尾工作, 如: 清理定时器</li></ol><h3 id="_2-6-6-即将废弃的勾子" tabindex="-1">2.6.6. 即将废弃的勾子 <a class="header-anchor" href="#_2-6-6-即将废弃的勾子" aria-label="Permalink to &quot;2.6.6. 即将废弃的勾子&quot;">​</a></h3><ol><li>componentWillMount</li><li>componentWillReceiveProps</li><li>componentWillUpdate</li></ol><p>现在使用会出现警告，下一个大版本需要加上UNSAFE_前缀才能使用，以后可能会被彻底废弃，不建议使用。</p><h2 id="_2-7-虚拟dom与dom-diffing算法" tabindex="-1">2.7. 虚拟DOM与DOM Diffing算法 <a class="header-anchor" href="#_2-7-虚拟dom与dom-diffing算法" aria-label="Permalink to &quot;2.7. 虚拟DOM与DOM Diffing算法&quot;">​</a></h2><h3 id="_2-7-1-效果" tabindex="-1">2.7.1. 效果 <a class="header-anchor" href="#_2-7-1-效果" aria-label="Permalink to &quot;2.7.1. 效果&quot;">​</a></h3><p>需求：验证虚拟DOM Diffing算法的存在</p><h3 id="_2-7-2-基本原理图" tabindex="-1">2.7.2. 基本原理图 <a class="header-anchor" href="#_2-7-2-基本原理图" aria-label="Permalink to &quot;2.7.2. 基本原理图&quot;">​</a></h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35560689/1690360347180-abf4b7ef-dbca-48ad-bc3b-90cb8abba965.png#averageHue=%23dfdede&amp;id=FrXCi&amp;originHeight=534&amp;originWidth=1334&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="png"></p><h1 id="第3章-react应用-基于react脚手架" tabindex="-1">第3章：React应用(基于React脚手架) <a class="header-anchor" href="#第3章-react应用-基于react脚手架" aria-label="Permalink to &quot;第3章：React应用(基于React脚手架)&quot;">​</a></h1><h2 id="_3-1-使用create-react-app创建react应用" tabindex="-1">3.1. 使用create-react-app创建react应用 <a class="header-anchor" href="#_3-1-使用create-react-app创建react应用" aria-label="Permalink to &quot;3.1. 使用create-react-app创建react应用&quot;">​</a></h2><h3 id="_3-1-1-react脚手架" tabindex="-1">3.1.1. react脚手架 <a class="header-anchor" href="#_3-1-1-react脚手架" aria-label="Permalink to &quot;3.1.1. react脚手架&quot;">​</a></h3><ol><li>xxx脚手架: 用来帮助程序员快速创建一个基于xxx库的模板项目 <ol><li>包含了所有需要的配置（语法检查、jsx编译、devServer…）</li><li>下载好了所有相关的依赖</li><li>可以直接运行一个简单效果</li></ol></li><li>react提供了一个用于创建react项目的脚手架库: create-react-app</li><li>项目的整体技术架构为: react + webpack + es6 + eslint</li><li>使用脚手架开发的项目的特点: 模块化, 组件化, 工程化</li></ol><h3 id="_3-1-2-创建项目并启动" tabindex="-1">3.1.2. 创建项目并启动 <a class="header-anchor" href="#_3-1-2-创建项目并启动" aria-label="Permalink to &quot;3.1.2. 创建项目并启动&quot;">​</a></h3><p>第一步，全局安装：npm i -g create-react-app 第二步，切换到想创项目的目录，使用命令：create-react-app hello-react 第三步，进入项目文件夹：cd hello-react 第四步，启动项目：npm start</p><h3 id="_3-1-3-react脚手架项目结构" tabindex="-1">3.1.3. react脚手架项目结构 <a class="header-anchor" href="#_3-1-3-react脚手架项目结构" aria-label="Permalink to &quot;3.1.3. react脚手架项目结构&quot;">​</a></h3><div class="language-html line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki one-dark-pro"><code><span class="line"><span style="color:#ABB2BF;">public ---- 静态资源文件夹</span></span>
<span class="line"><span style="color:#ABB2BF;">  favicon.icon ------ 网站页签图标</span></span>
<span class="line"><span style="color:#ABB2BF;">  index.html -------- 主页面</span></span>
<span class="line"><span style="color:#ABB2BF;">  logo192.png ------- logo图</span></span>
<span class="line"><span style="color:#ABB2BF;">  logo512.png ------- logo图</span></span>
<span class="line"><span style="color:#ABB2BF;">  manifest.json ----- 应用加壳的配置文件</span></span>
<span class="line"><span style="color:#ABB2BF;">  robots.txt -------- 爬虫协议文件</span></span>
<span class="line"><span style="color:#ABB2BF;">src ---- 源码文件夹</span></span>
<span class="line"><span style="color:#ABB2BF;">  App.css -------- App组件的样式</span></span>
<span class="line"><span style="color:#ABB2BF;">  App.js --------- App组件</span></span>
<span class="line"><span style="color:#ABB2BF;">  App.test.js ---- 用于给App做测试</span></span>
<span class="line"><span style="color:#ABB2BF;">  index.css ------ 样式</span></span>
<span class="line"><span style="color:#ABB2BF;">  index.js ------- 入口文件</span></span>
<span class="line"><span style="color:#ABB2BF;">  logo.svg ------- logo图</span></span>
<span class="line"><span style="color:#ABB2BF;">  reportWebVitals.js</span></span>
<span class="line"><span style="color:#ABB2BF;">   --- 页面性能分析文件(需要web-vitals库的支持)</span></span>
<span class="line"><span style="color:#ABB2BF;">  setupTests.js</span></span>
<span class="line"><span style="color:#ABB2BF;">   ---- 组件单元测试的文件(需要jest-dom库的支持)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><h3 id="_3-1-4-功能界面的组件化编码流程-通用" tabindex="-1">3.1.4. 功能界面的组件化编码流程（通用） <a class="header-anchor" href="#_3-1-4-功能界面的组件化编码流程-通用" aria-label="Permalink to &quot;3.1.4. 功能界面的组件化编码流程（通用）&quot;">​</a></h3><ol><li>拆分组件: 拆分界面,抽取组件</li><li>实现静态组件: 使用组件实现静态页面效果</li><li>实现动态组件 3.1 动态显示初始化数据 3.1.1 数据类型 3.1.2 数据名称 3.1.2 保存在哪个组件? 3.2 交互(从绑定事件监听开始)</li></ol><h2 id="_3-2-组件的组合使用-todolist" tabindex="-1">3.2. 组件的组合使用-TodoList <a class="header-anchor" href="#_3-2-组件的组合使用-todolist" aria-label="Permalink to &quot;3.2. 组件的组合使用-TodoList&quot;">​</a></h2><p><em>功能: 组件化实现此功能</em><em>1. 显示所有todo列表</em><em>2. 输入文本, 点击按钮显示到列表的首位, 并清除输入的文本</em></p><h2 id="_4-4-消息订阅-发布机制" tabindex="-1">4.4. 消息订阅-发布机制 <a class="header-anchor" href="#_4-4-消息订阅-发布机制" aria-label="Permalink to &quot;4.4. 消息订阅-发布机制&quot;">​</a></h2><div class="language-vb line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">vb</span><pre class="shiki one-dark-pro"><code><span class="line"><span style="color:#D19A66;">1</span><span style="color:#ABB2BF;">. 工具库: PubSubJS</span></span>
<span class="line"><span style="color:#D19A66;">2</span><span style="color:#ABB2BF;">. 下载: npm install </span><span style="color:#E06C75;">pubsub</span><span style="color:#ABB2BF;">-</span><span style="color:#E06C75;">js</span><span style="color:#ABB2BF;"> --</span><span style="color:#E06C75;">save</span></span>
<span class="line"><span style="color:#D19A66;">3</span><span style="color:#ABB2BF;">. 使用:</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-dark-pro"><code><span class="line"><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">import</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">PubSub</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">from</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">&#39;pubsub-js&#39;</span><span style="color:#ABB2BF;"> </span><span style="color:#7F848E;font-style:italic;">//引入</span></span>
<span class="line"><span style="color:#ABB2BF;">         </span><span style="color:#E5C07B;">PubSub</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">subscribe</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&#39;delete&#39;</span><span style="color:#ABB2BF;">, </span><span style="color:#C678DD;">function</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;font-style:italic;">data</span><span style="color:#ABB2BF;">){ }); </span><span style="color:#7F848E;font-style:italic;">//订阅</span></span>
<span class="line"><span style="color:#ABB2BF;">         </span><span style="color:#E5C07B;">PubSub</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">publish</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&#39;delete&#39;</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;">data</span><span style="color:#ABB2BF;">) </span><span style="color:#7F848E;font-style:italic;">//发布消息</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h1 id="第5章-react路由" tabindex="-1">第5章 React路由 <a class="header-anchor" href="#第5章-react路由" aria-label="Permalink to &quot;第5章 React路由&quot;">​</a></h1><h2 id="_5-1-相关理解" tabindex="-1">5.1 相关理解 <a class="header-anchor" href="#_5-1-相关理解" aria-label="Permalink to &quot;5.1 相关理解&quot;">​</a></h2><h3 id="_5-1-1-spa的理解" tabindex="-1">5.1.1. SPA的理解 <a class="header-anchor" href="#_5-1-1-spa的理解" aria-label="Permalink to &quot;5.1.1. SPA的理解&quot;">​</a></h3><ol><li>单页Web应用（single page web application，SPA）。</li><li>整个应用只有一个完整的页面。</li><li>点击页面中的链接不会刷新页面，只会做页面的局部更新。</li><li>数据都需要通过ajax请求获取, 并在前端异步展现。</li></ol><h3 id="_5-1-2-路由的理解" tabindex="-1">5.1.2. 路由的理解 <a class="header-anchor" href="#_5-1-2-路由的理解" aria-label="Permalink to &quot;5.1.2. 路由的理解&quot;">​</a></h3><ol><li>什么是路由? <ol><li>一个路由就是一个映射关系(key:value)</li><li>key为路径, value可能是function或component</li></ol></li><li>路由分类 <ol><li>后端路由： <ol><li>理解： value是function, 用来处理客户端提交的请求。</li><li>注册路由： router.get(path, function(req, res))</li><li>工作过程：当node接收到一个请求时, 根据请求路径找到匹配的路由, 调用路由中的函数来处理请求, 返回响应数据</li></ol></li><li>前端路由： <ol><li>浏览器端路由，value是component，用于展示页面内容。</li><li>注册路由: <code>&lt;Route path=&quot;/test&quot; component={Test}&gt;</code></li><li>工作过程：当浏览器的path变为/test时, 当前路由组件就会变为Test组件</li></ol></li></ol></li></ol><h3 id="_5-1-3-react-router-dom的理解" tabindex="-1">5.1.3. react-router-dom的理解 <a class="header-anchor" href="#_5-1-3-react-router-dom的理解" aria-label="Permalink to &quot;5.1.3. react-router-dom的理解&quot;">​</a></h3><ol><li>react的一个插件库。</li><li>专门用来实现一个SPA应用。</li><li>基于react的项目基本都会用到此库。</li></ol><h2 id="_5-2-react-router-dom相关api" tabindex="-1">5.2. react-router-dom相关API <a class="header-anchor" href="#_5-2-react-router-dom相关api" aria-label="Permalink to &quot;5.2. react-router-dom相关API&quot;">​</a></h2><h3 id="_5-2-1-内置组件" tabindex="-1">5.2.1. 内置组件 <a class="header-anchor" href="#_5-2-1-内置组件" aria-label="Permalink to &quot;5.2.1. 内置组件&quot;">​</a></h3><div class="language-html line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki one-dark-pro"><code><span class="line"><span style="color:#ABB2BF;">&lt;</span><span style="color:#E06C75;">BrowserRouter</span><span style="color:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF;">&lt;</span><span style="color:#E06C75;">HashRouter</span><span style="color:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF;">&lt;</span><span style="color:#E06C75;">Route</span><span style="color:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF;">&lt;</span><span style="color:#E06C75;">Redirect</span><span style="color:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF;">&lt;</span><span style="color:#E06C75;">Link</span><span style="color:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF;">&lt;</span><span style="color:#E06C75;">NavLink</span><span style="color:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF;">&lt;</span><span style="color:#E06C75;">Switch</span><span style="color:#ABB2BF;">&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="_5-2-2-其它" tabindex="-1">5.2.2. 其它 <a class="header-anchor" href="#_5-2-2-其它" aria-label="Permalink to &quot;5.2.2. 其它&quot;">​</a></h3><ol><li>history对象</li><li>match对象</li><li>withRouter函数</li></ol><h2 id="_5-3-基本路由使用" tabindex="-1">5.3. 基本路由使用 <a class="header-anchor" href="#_5-3-基本路由使用" aria-label="Permalink to &quot;5.3. 基本路由使用&quot;">​</a></h2><h3 id="_5-3-1-效果" tabindex="-1">5.3.1. 效果 <a class="header-anchor" href="#_5-3-1-效果" aria-label="Permalink to &quot;5.3.1. 效果&quot;">​</a></h3><h3 id="_5-3-2-准备" tabindex="-1">5.3.2. 准备 <a class="header-anchor" href="#_5-3-2-准备" aria-label="Permalink to &quot;5.3.2. 准备&quot;">​</a></h3><ol><li>下载react-router-dom: npm install --save react-router-dom</li><li>引入bootstrap.css: <code>&lt;link rel=&quot;stylesheet&quot; href=&quot;/css/bootstrap.css&quot;&gt;</code></li></ol><h2 id="_5-4-嵌套路由使用" tabindex="-1">5.4. 嵌套路由使用 <a class="header-anchor" href="#_5-4-嵌套路由使用" aria-label="Permalink to &quot;5.4. 嵌套路由使用&quot;">​</a></h2><h3 id="效果" tabindex="-1">效果 <a class="header-anchor" href="#效果" aria-label="Permalink to &quot;效果&quot;">​</a></h3><h2 id="_5-5-向路由组件传递参数数据" tabindex="-1">5.5. 向路由组件传递参数数据 <a class="header-anchor" href="#_5-5-向路由组件传递参数数据" aria-label="Permalink to &quot;5.5. 向路由组件传递参数数据&quot;">​</a></h2><h2 id="_5-6-多种路由跳转方式" tabindex="-1">5.6. 多种路由跳转方式 <a class="header-anchor" href="#_5-6-多种路由跳转方式" aria-label="Permalink to &quot;5.6. 多种路由跳转方式&quot;">​</a></h2><h1 id="第6章-react-ui组件库" tabindex="-1">第6章：React UI组件库 <a class="header-anchor" href="#第6章-react-ui组件库" aria-label="Permalink to &quot;第6章：React UI组件库&quot;">​</a></h1><h2 id="_6-1-流行的开源react-ui组件库" tabindex="-1">6.1.流行的开源React UI组件库 <a class="header-anchor" href="#_6-1-流行的开源react-ui组件库" aria-label="Permalink to &quot;6.1.流行的开源React UI组件库&quot;">​</a></h2><h3 id="_6-1-1-material-ui-国外" tabindex="-1">6.1.1. material-ui(国外) <a class="header-anchor" href="#_6-1-1-material-ui-国外" aria-label="Permalink to &quot;6.1.1. material-ui(国外)&quot;">​</a></h3><ol><li>官网: <a href="http://www.material-ui.com/#/" target="_blank" rel="noreferrer">http://www.material-ui.com/#/</a></li><li>github: <a href="https://github.com/callemall/material-ui" target="_blank" rel="noreferrer">https://github.com/callemall/material-ui</a></li></ol><h3 id="_6-1-2-ant-design-国内蚂蚁金服" tabindex="-1">6.1.2. ant-design(国内蚂蚁金服) <a class="header-anchor" href="#_6-1-2-ant-design-国内蚂蚁金服" aria-label="Permalink to &quot;6.1.2. ant-design(国内蚂蚁金服)&quot;">​</a></h3><ol><li>官网: <a href="https://ant.design/index-cn" target="_blank" rel="noreferrer">https://ant.design/index-cn</a></li><li>Github: <a href="https://github.com/ant-design/ant-design/" target="_blank" rel="noreferrer">https://github.com/ant-design/ant-design/</a></li></ol><h1 id="第7章-redux" tabindex="-1">第7章：redux <a class="header-anchor" href="#第7章-redux" aria-label="Permalink to &quot;第7章：redux&quot;">​</a></h1><h2 id="_7-1-redux理解" tabindex="-1">7.1. redux理解 <a class="header-anchor" href="#_7-1-redux理解" aria-label="Permalink to &quot;7.1. redux理解&quot;">​</a></h2><h3 id="_7-1-1-学习文档" tabindex="-1">7.1.1. 学习文档 <a class="header-anchor" href="#_7-1-1-学习文档" aria-label="Permalink to &quot;7.1.1. 学习文档&quot;">​</a></h3><ol><li>英文文档: <a href="https://redux.js.org/" target="_blank" rel="noreferrer">https://redux.js.org/</a></li><li>中文文档: <a href="http://www.redux.org.cn/" target="_blank" rel="noreferrer">http://www.redux.org.cn/</a></li><li>Github: <a href="https://github.com/reactjs/redux" target="_blank" rel="noreferrer">https://github.com/reactjs/redux</a></li></ol><h3 id="_7-1-2-redux是什么" tabindex="-1">7.1.2. redux是什么 <a class="header-anchor" href="#_7-1-2-redux是什么" aria-label="Permalink to &quot;7.1.2. redux是什么&quot;">​</a></h3><ol><li>redux是一个专门用于做状态管理的JS库(不是react插件库)。</li><li>它可以用在react, angular, vue等项目中, 但基本与react配合使用。</li><li>作用: 集中式管理react应用中多个组件共享的状态。</li></ol><h3 id="_7-1-3-什么情况下需要使用redux" tabindex="-1">7.1.3. 什么情况下需要使用redux <a class="header-anchor" href="#_7-1-3-什么情况下需要使用redux" aria-label="Permalink to &quot;7.1.3. 什么情况下需要使用redux&quot;">​</a></h3><ol><li>某个组件的状态，需要让其他组件可以随时拿到（共享）。</li><li>一个组件需要改变另一个组件的状态（通信）。</li><li>总体原则：能不用就不用, 如果不用比较吃力才考虑使用。</li></ol><h3 id="_7-1-4-redux工作流程" tabindex="-1">7.1.4. redux工作流程 <a class="header-anchor" href="#_7-1-4-redux工作流程" aria-label="Permalink to &quot;7.1.4. redux工作流程&quot;">​</a></h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35560689/1690360347736-b5638a86-52fd-4ad8-865f-33051059b19b.png#averageHue=%23f8f4ee&amp;id=wayHR&amp;originHeight=720&amp;originWidth=1280&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="png"></p><h2 id="_7-2-redux的三个核心概念" tabindex="-1">7.2. redux的三个核心概念 <a class="header-anchor" href="#_7-2-redux的三个核心概念" aria-label="Permalink to &quot;7.2. redux的三个核心概念&quot;">​</a></h2><h3 id="_7-2-1-action" tabindex="-1">7.2.1. action <a class="header-anchor" href="#_7-2-1-action" aria-label="Permalink to &quot;7.2.1. action&quot;">​</a></h3><ol><li>动作的对象</li><li>包含2个属性 <ul><li>type：标识属性, 值为字符串, 唯一, 必要属性</li><li>data：数据属性, 值类型任意, 可选属性</li></ul></li><li>例子：{ type: &#39;ADD_STUDENT&#39;,data:{name: &#39;tom&#39;,age:18} }</li></ol><h3 id="_7-2-2-reducer" tabindex="-1">7.2.2. reducer <a class="header-anchor" href="#_7-2-2-reducer" aria-label="Permalink to &quot;7.2.2. reducer&quot;">​</a></h3><ol><li>用于初始化状态、加工状态。</li><li>加工时，根据旧的state和action， 产生新的state的纯函数。</li></ol><h3 id="_7-2-3-store" tabindex="-1">7.2.3. store <a class="header-anchor" href="#_7-2-3-store" aria-label="Permalink to &quot;7.2.3. store&quot;">​</a></h3><ol><li>将state、action、reducer联系在一起的对象</li><li>如何得到此对象?</li></ol><p>import {createStore} from &#39;redux&#39; import reducer from &#39;./reducers&#39; const store = createStore(reducer)</p><ol><li>此对象的功能?</li></ol><p>getState(): 得到state dispatch(action): 分发action, 触发reducer调用, 产生新的state subscribe(listener): 注册监听, 当产生了新的state时, 自动调用</p><h2 id="_7-3-redux的核心api" tabindex="-1">7.3. redux的核心API <a class="header-anchor" href="#_7-3-redux的核心api" aria-label="Permalink to &quot;7.3. redux的核心API&quot;">​</a></h2><h3 id="_7-3-1-createstore" tabindex="-1">7.3.1. createstore() <a class="header-anchor" href="#_7-3-1-createstore" aria-label="Permalink to &quot;7.3.1. createstore()&quot;">​</a></h3><p>作用：创建包含指定reducer的store对象</p><h3 id="_7-3-2-store对象" tabindex="-1">7.3.2. store对象 <a class="header-anchor" href="#_7-3-2-store对象" aria-label="Permalink to &quot;7.3.2. store对象&quot;">​</a></h3><ol><li>作用: redux库最核心的管理对象</li><li>它内部维护着: 1. state 2. reducer</li><li>核心方法: 1. getState() 2. dispatch(action) 3. subscribe(listener)</li><li>具体编码: 1. store.getState() 2. store.dispatch({type:&#39;INCREMENT&#39;, number}) 3. store.subscribe(render)</li></ol><h3 id="_7-3-3-applymiddleware" tabindex="-1">7.3.3. applyMiddleware() <a class="header-anchor" href="#_7-3-3-applymiddleware" aria-label="Permalink to &quot;7.3.3. applyMiddleware()&quot;">​</a></h3><p>作用：应用上基于redux的中间件(插件库)</p><h3 id="_7-3-4-combinereducers" tabindex="-1">7.3.4. combineReducers() <a class="header-anchor" href="#_7-3-4-combinereducers" aria-label="Permalink to &quot;7.3.4. combineReducers()&quot;">​</a></h3><p>作用：合并多个reducer函数</p><h2 id="_7-4-使用redux编写应用" tabindex="-1">7.4. 使用redux编写应用 <a class="header-anchor" href="#_7-4-使用redux编写应用" aria-label="Permalink to &quot;7.4. 使用redux编写应用&quot;">​</a></h2><h2 id="_7-5-redux异步编程" tabindex="-1">7.5. redux异步编程 <a class="header-anchor" href="#_7-5-redux异步编程" aria-label="Permalink to &quot;7.5. redux异步编程&quot;">​</a></h2><h3 id="_7-5-1理解" tabindex="-1">7.5.1理解 <a class="header-anchor" href="#_7-5-1理解" aria-label="Permalink to &quot;7.5.1理解&quot;">​</a></h3><ol><li>redux默认是不能进行异步处理的,</li><li>某些时候应用中需要在redux中执行异步任务(ajax, 定时器)</li></ol><h3 id="_7-5-2-使用异步中间件" tabindex="-1">7.5.2. 使用异步中间件 <a class="header-anchor" href="#_7-5-2-使用异步中间件" aria-label="Permalink to &quot;7.5.2. 使用异步中间件&quot;">​</a></h3><p>npm install --save redux-thunk</p><h2 id="_7-6-react-redux" tabindex="-1">7.6. react-redux <a class="header-anchor" href="#_7-6-react-redux" aria-label="Permalink to &quot;7.6. react-redux&quot;">​</a></h2><h3 id="_7-6-1-理解" tabindex="-1">7.6.1. 理解 <a class="header-anchor" href="#_7-6-1-理解" aria-label="Permalink to &quot;7.6.1. 理解&quot;">​</a></h3><ol><li>一个react插件库</li><li>专门用来简化react应用中使用redux</li></ol><h3 id="_7-6-2-react-redux将所有组件分成两大类" tabindex="-1">7.6.2. react-Redux将所有组件分成两大类 <a class="header-anchor" href="#_7-6-2-react-redux将所有组件分成两大类" aria-label="Permalink to &quot;7.6.2. react-Redux将所有组件分成两大类&quot;">​</a></h3><ol><li>UI组件 <ol><li>只负责 UI 的呈现，不带有任何业务逻辑</li><li>通过props接收数据(一般数据和函数)</li><li>不使用任何 Redux 的 API</li><li>一般保存在components文件夹下</li></ol></li><li>容器组件 <ol><li>负责管理数据和业务逻辑，不负责UI的呈现</li><li>使用 Redux 的 API</li><li>一般保存在containers文件夹下</li></ol></li></ol><h3 id="_7-6-3-相关api" tabindex="-1">7.6.3. 相关API <a class="header-anchor" href="#_7-6-3-相关api" aria-label="Permalink to &quot;7.6.3. 相关API&quot;">​</a></h3><ol><li>Provider：让所有组件都可以得到state数据</li></ol><div class="language-jsx line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki one-dark-pro"><code><span class="line"></span>
<span class="line"><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">Provider</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;font-style:italic;">store</span><span style="color:#56B6C2;">=</span><span style="color:#C678DD;">{</span><span style="color:#E06C75;">store</span><span style="color:#C678DD;">}</span><span style="color:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF;">   &lt;</span><span style="color:#E5C07B;">App</span><span style="color:#ABB2BF;"> /&gt;</span></span>
<span class="line"><span style="color:#ABB2BF;">&lt;/</span><span style="color:#E5C07B;">Provider</span><span style="color:#ABB2BF;">&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ol><li>connect：用于包装 UI 组件生成容器组件</li></ol><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-dark-pro"><code><span class="line"><span style="color:#C678DD;">import</span><span style="color:#ABB2BF;"> { </span><span style="color:#E06C75;">connect</span><span style="color:#ABB2BF;"> } </span><span style="color:#C678DD;">from</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">&#39;react-redux&#39;</span></span>
<span class="line"><span style="color:#61AFEF;">connect</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">mapStateToprops</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;">mapDispatchToProps</span><span style="color:#ABB2BF;">)(</span><span style="color:#E06C75;">Counter</span><span style="color:#ABB2BF;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ol><li>mapStateToprops：将外部的数据（即state对象）转换为UI组件的标签属性</li></ol><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-dark-pro"><code><span class="line"><span style="color:#C678DD;">const</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">mapStateToprops</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">function</span><span style="color:#ABB2BF;"> (</span><span style="color:#E06C75;font-style:italic;">state</span><span style="color:#ABB2BF;">) {</span></span>
<span class="line"><span style="color:#ABB2BF;">   </span><span style="color:#C678DD;">return</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#ABB2BF;">      </span><span style="color:#E06C75;">value</span><span style="color:#ABB2BF;">: </span><span style="color:#E06C75;">state</span></span>
<span class="line"><span style="color:#ABB2BF;">   }</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ol><li>mapDispatchToProps：将分发action的函数转换为UI组件的标签属性</li></ol><h2 id="_7-7-使用上redux调试工具" tabindex="-1">7.7. 使用上redux调试工具 <a class="header-anchor" href="#_7-7-使用上redux调试工具" aria-label="Permalink to &quot;7.7. 使用上redux调试工具&quot;">​</a></h2><h3 id="_7-7-1-安装chrome浏览器插件" tabindex="-1">7.7.1. 安装chrome浏览器插件 <a class="header-anchor" href="#_7-7-1-安装chrome浏览器插件" aria-label="Permalink to &quot;7.7.1. 安装chrome浏览器插件&quot;">​</a></h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35560689/1690360348077-6868d5cc-4556-4a6f-9681-68366f13ab5f.png#averageHue=%23f2efed&amp;id=Cw2wJ&amp;originHeight=375&amp;originWidth=1206&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="png"></p><h3 id="_7-7-2-下载工具依赖包" tabindex="-1">7.7.2. 下载工具依赖包 <a class="header-anchor" href="#_7-7-2-下载工具依赖包" aria-label="Permalink to &quot;7.7.2. 下载工具依赖包&quot;">​</a></h3><div class="language-vb line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">vb</span><pre class="shiki one-dark-pro"><code><span class="line"><span style="color:#ABB2BF;">npm </span><span style="color:#E06C75;">install</span><span style="color:#ABB2BF;"> --</span><span style="color:#E06C75;">save</span><span style="color:#ABB2BF;">-</span><span style="color:#E06C75;">dev</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">redux</span><span style="color:#ABB2BF;">-</span><span style="color:#E06C75;">devtools</span><span style="color:#ABB2BF;">-</span><span style="color:#E06C75;">extension</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h2 id="_7-8-纯函数和高阶函数" tabindex="-1">7.8. 纯函数和高阶函数 <a class="header-anchor" href="#_7-8-纯函数和高阶函数" aria-label="Permalink to &quot;7.8. 纯函数和高阶函数&quot;">​</a></h2><h3 id="_7-8-1-纯函数" tabindex="-1">7.8.1. 纯函数 <a class="header-anchor" href="#_7-8-1-纯函数" aria-label="Permalink to &quot;7.8.1. 纯函数&quot;">​</a></h3><ol><li>一类特别的函数: 只要是同样的输入(实参)，必定得到同样的输出(返回)</li><li>必须遵守以下一些约束 <ol><li>不得改写参数数据</li><li>不会产生任何副作用，例如网络请求，输入和输出设备</li><li>不能调用Date.now()或者Math.random()等不纯的方法</li></ol></li><li>redux的reducer函数必须是一个纯函数</li></ol><h3 id="_7-8-2-高阶函数" tabindex="-1">7.8.2. 高阶函数 <a class="header-anchor" href="#_7-8-2-高阶函数" aria-label="Permalink to &quot;7.8.2. 高阶函数&quot;">​</a></h3><ol><li>理解: 一类特别的函数 <ol><li>情况1: 参数是函数</li><li>情况2: 返回是函数</li></ol></li><li>常见的高阶函数: <ol><li>定时器设置函数</li><li>数组的forEach()/map()/filter()/reduce()/find()/bind()</li><li>promise</li><li>react-redux中的connect函数</li></ol></li><li>作用: 能实现更加动态, 更加可扩展的功能</li></ol>`,150);function c(d,h,u,m,b,B){const e=s("Person");return n(),r("div",null,[i,o(e,{"{..._person_}":""}),p])}const _=l(t,[["render",c]]);export{f as __pageData,_ as default};
