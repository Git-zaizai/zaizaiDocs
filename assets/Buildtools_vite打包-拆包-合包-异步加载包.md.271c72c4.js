import{_ as n,o as e,c as l,k as s,a as o,t as p,Q as t}from"./chunks/framework.7518ccd6.js";const b=JSON.parse('{"title":"vite打包-拆包-合包-异步加载包","description":"","frontmatter":{"title":"vite打包-拆包-合包-异步加载包"},"headers":[],"relativePath":"Buildtools/vite打包-拆包-合包-异步加载包.md","filePath":"Buildtools/vite打包-拆包-合包-异步加载包.md","lastUpdated":1722251927000}'),r={name:"Buildtools/vite打包-拆包-合包-异步加载包.md"},c={id:"frontmatter-title",tabindex:"-1"},i=s("a",{class:"header-anchor",href:"#frontmatter-title","aria-label":'Permalink to "{{$frontmatter.title}}"'},"​",-1),B=t(`<h2 id="打包" tabindex="-1">打包 <a class="header-anchor" href="#打包" aria-label="Permalink to &quot;打包&quot;">​</a></h2><p><strong>什么样的资源会被打包？</strong></p><p>从入口文件开始，进行扩散性关联扫描，被引用且被使用过至少 1 次的资源会被打包</p><p><strong>什么样的文件会被独立成一个包？</strong></p><ul><li>默认情况下，被引用了至少两次的文件，会被打成一个独立的包</li></ul><p>如: <code>Utils01.ts</code> 被 <code>Main.vue</code>, <code>Other.vue</code> 两个 vue 文件引用，则<code>Utils01.ts</code>会被打成一个独立的包</p><ul><li>异步组件（含普通异步组件以及异步路由组件）会被打成一个独立包</li></ul><p><strong>什么样的资源会被合并打包？</strong></p><ul><li>默认情况下，只被引用了一次的文件会被合并到调用处打包</li></ul><p>如：<code>Utils01.ts</code> 只被 <code>Other.vue</code> 文件引用，则<code>Utils01.ts</code>会被打包到<code>Other.vue</code>中</p><ul><li>通过动态扫描引入的包会被合并打包.</li></ul><p>这里的合并打包有两种情况：</p><ol><li>动态扫描引入的 vue 文件只在一个 vue 组件中使用，那么动态引入的 vue 文件，会被合并打包到调用处</li><li>动态扫描引入的 vue 文件在多个 vue 组件中使用，那么动态引入的 vue 文件，会被合并打包到一个单独的 chunk</li></ol><div class="language-ts line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki one-dark-pro"><code><span class="line"><span style="color:#C678DD;">import</span><span style="color:#ABB2BF;"> { </span><span style="color:#E06C75;">Component</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">as</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">VueComponent</span><span style="color:#ABB2BF;"> } </span><span style="color:#C678DD;">from</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">&#39;vue&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;">const</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">compMap</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">new</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">Map</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">string</span><span style="color:#ABB2BF;">, </span><span style="color:#E5C07B;">VueComponent</span><span style="color:#ABB2BF;">&gt;()</span></span>
<span class="line"><span style="color:#C678DD;">const</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">mockFiles</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">import</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">meta</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">glob</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&#39;./demo/*.vue&#39;</span><span style="color:#ABB2BF;">, {</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#E06C75;">eager</span><span style="color:#ABB2BF;">: </span><span style="color:#D19A66;">true</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#E06C75;">import</span><span style="color:#ABB2BF;">: </span><span style="color:#98C379;">&#39;default&#39;</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#ABB2BF;">})</span></span>
<span class="line"><span style="color:#E5C07B;">Object</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">keys</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">mockFiles</span><span style="color:#ABB2BF;">).</span><span style="color:#61AFEF;">forEach</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;font-style:italic;">key</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">=&gt;</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#C678DD;">const</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">defaultObj</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">mockFiles</span><span style="color:#ABB2BF;">[</span><span style="color:#E06C75;">key</span><span style="color:#ABB2BF;">]</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#7F848E;font-style:italic;">//@ts-ignore</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#E5C07B;">compMap</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">set</span><span style="color:#ABB2BF;">(</span><span style="color:#E5C07B;">defaultObj</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">name</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;">defaultObj</span><span style="color:#ABB2BF;">)</span></span>
<span class="line"><span style="color:#ABB2BF;">})</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h2 id="如何手动合并零碎的文件" tabindex="-1">如何手动合并零碎的文件 <a class="header-anchor" href="#如何手动合并零碎的文件" aria-label="Permalink to &quot;如何手动合并零碎的文件&quot;">​</a></h2><p><strong>chunk 碎片 是如何产生的？</strong></p><p>除了入口点（静态入口点、动态入口点）单独生成一个 chunk 之外，当一个模块被 2 个或以上的 <code>chunk</code> 引用，这个模块会单独生成一个 <code>chunk</code>。</p><p>而模块信息中，有两个字段可以利用，一个是 <code>importers</code>，一个是 <code>dynamicImporters</code>，对应着当前模块被静态引入的模块，以及被动态引入的模块。</p><p>当前模块的 <code>importers.length + dynamicImporters.length &gt; 1</code>，就可以认为当前模块会被单独打成一个<code>chunk</code></p><p><strong>如何通过手动分包解决 chunk 碎片 问题？</strong></p><p>让多个<code>module</code>拥有相同的<code>chunk名称</code></p><h2 id="如何鉴别哪些需要合包" tabindex="-1">如何鉴别哪些需要合包？ <a class="header-anchor" href="#如何鉴别哪些需要合包" aria-label="Permalink to &quot;如何鉴别哪些需要合包？&quot;">​</a></h2><p>碎片化的产物可能需要合包</p><h2 id="如何判断合包或拆包之后-是有效优化" tabindex="-1">如何判断合包或拆包之后，是有效优化？ <a class="header-anchor" href="#如何判断合包或拆包之后-是有效优化" aria-label="Permalink to &quot;如何判断合包或拆包之后，是有效优化？&quot;">​</a></h2><p>某个界面，在资源请求数量没有明显增多的情况下，总资源量变小了。特别要注意合包之后，不要导致首页资源加载变多</p><h2 id="基于-vite3-发现的一些手动合包-拆包的规律" tabindex="-1">基于 vite3 发现的一些手动合包/拆包的规律 <a class="header-anchor" href="#基于-vite3-发现的一些手动合包-拆包的规律" aria-label="Permalink to &quot;基于 vite3 发现的一些手动合包/拆包的规律&quot;">​</a></h2><ol><li>如果 chunk 中的有 1 个 module 有在首页使用到，那么该 chunk 必然会在首页加载（这可能导致首页加载了不必要的资源）</li><li>如果对异步路由组件进行合包，那被合包的 chunk, 必然会在首页加载（这个异步路由对于首页而言，可能也是不必要的资源）</li><li>如果对异步组件(如:<code>const HelloWorld = defineAsyncComponent(() =&gt; import(&#39;./HelloWorld.vue&#39;))</code>)进行合包, 则该合包的 chunk 必然会在首页加载（这个异步组件对于首页而言，可能也是不必要的资源）</li><li>vite3 默认会根据引用情况对第三方依赖，进行拆包/合包，通常情况比我们自己再进行拆包合包形成的包的大小更合理（更小）</li></ol><p>总结：</p><ol><li>尽量只对自己编写的碎片化的普通 ts/js 文件进行合包(所谓普通 ts/js 如：XxxUtil, XxxApi 之类的)</li><li>不要对异步路由组件进行合包</li><li>不要对异步组件合包，除非该 chunk 中所有的异步组件本来就要在首页使用</li><li>尽量不要手动对第三方依赖进行合包/分包</li></ol><h2 id="参考资料" tabindex="-1">参考资料 <a class="header-anchor" href="#参考资料" aria-label="Permalink to &quot;参考资料&quot;">​</a></h2><p><a href="https://juejin.cn/post/7103730522517569567" target="_blank" rel="noreferrer">分析 vite2.x/rollup 分包原理，解决 chunk 碎片问题</a></p><p><a href="https://blog.csdn.net/sinat_37255207/article/details/126574286" target="_blank" rel="noreferrer">Vite 如何打包分割代码</a></p><p><a href="https://segmentfault.com/a/1190000041464140" target="_blank" rel="noreferrer">记一次 vite2.x 打包优化过程</a></p><p><a href="https://www.cnblogs.com/jyk/p/16029074.html" target="_blank" rel="noreferrer">vite2 打包的时候 vendor-xxx.js 文件过大的解决方法</a></p><p><a href="https://www.cnblogs.com/guangzan/p/14807289.html" target="_blank" rel="noreferrer">Vite 异步 Chunk 加载优化</a></p>`,35);function d(a,y,u,h,m,F){return e(),l("div",null,[s("h1",c,[o(p(a.$frontmatter.title)+" ",1),i]),B])}const _=n(r,[["render",d]]);export{b as __pageData,_ as default};
